# Process Drills

```elixir
Mix.install([
  {:youtube, github: "brooklinjazz/youtube"},
  {:hidden_cell, github: "brooklinjazz/hidden_cell"}
])
```

## Navigation

[Return Home](../start.livemd)<span style="padding: 0 30px"></span>
[Report An Issue](https://github.com/DockYard-Academy/beta_curriculum/issues/new?assignees=&labels=&template=issue.md&title=)

## Process Drills

Drills help you develop familiarity and muscle memory with syntax through repeated exercises. Unlike usual problems, Drills are not intended to develop problem solving skills, they are purely for developing comfort and speed.

This set of drills is for the [Process](https://hexdocs.pm/elixir/Process.html) module follow the instructions for each drill and complete them as quickly as you can.

## Process.send/3

Use [Process.send/3](https://hexdocs.pm/elixir/Process.html#send/3) and `self()` to send the process for the Elixir cell below a `:message` message. Use [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) to receive the message in the same cell.

```elixir
Process.send(self(), :message, [])

receive do
  :flowerpot -> "No"
  :message -> "This is the one"
end
```

Use [Process.send/3](https://hexdocs.pm/elixir/Process.html#send/3) and `self()` to send the process for the Elixir cell below a message with a value i.e. `{:message, "value"}`. Use [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) to receive the message in the same cell and return the value.

```elixir
Process.send(self(), {:message, "Guadalajara"}, [])

receive do
  {:message, value} -> value
end
```

## Process.spawn/2

Use [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) to spawn a new process which adds two integers together.

```elixir
Process.spawn(fn -> 1 + 1 end, [])
```

Use [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) and [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) to spawn a process that sleeps for five seconds, then prints "Finished!".

```elixir
Process.spawn(
  fn ->
    Process.sleep(5000)
    IO.puts("Finished")
  end,
  []
)
```

Use [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) and [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) to spawn a process that receives a `:message` message. Use [Process.send/3](https://hexdocs.pm/elixir/Process.html#send/3) to send the spawned process a `:message` message. The spawned process should print `"received a message!"`.

```elixir
# my_process = Process.spawn(
#   receive do
#     :message -> IO.puts("Received a message!")
#   end
# )

# Process.send(my_process, :message, [])
```

Use [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) and [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) to spawn a process that receives a message with a value i.e. `{:message, "value"}`. Use [Process.send/3](https://hexdocs.pm/elixir/Process.html#send/3) to send the spawned process a message with a value. The spawned process should print the received value.

```elixir
my_process =
  Process.spawn(
    fn ->
      receive do
        {:message, value} -> IO.puts(value)
      end
    end,
    []
  )

# receive do
#   {:message, value} -> value
# end,

Process.send(my_process, {:message, "Code Is Poetry"}, [])
```

Use `Process.spawn` to spawn a process that raises an error. Notice it does not crash the Livebook, because it is an **unlinked** process.

```elixir
Process.spawn(fn -> raise "Error Terror!" end, [])
```

Use [Process.spawn/3](https://hexdocs.pm/elixir/Process.html#spawn/3) and [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) to spawn a process which raises an error after one second. Use [Process.link/1](https://hexdocs.pm/elixir/Process.html#link/1) to link the process.

Livebook should crash. Comment out your solution so that you can move on.

```elixir
# a_process = Process.spawn(fn -> 
#   Process.sleep(1000) 
#   raise "Error Terror" end,
#   [])

# Process.link(a_process)
```

## Process.alive?/1

```elixir

```

Use [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) and [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) to spawn a process that sleeps for five seconds. Use [Process.alive?/1](https://hexdocs.pm/elixir/Process.html#alive?/1) and [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) to check if the process is alive after two seconds. [Process.alive?/1](https://hexdocs.pm/elixir/Process.html#alive?/1) should return `true`.

```elixir
my_process =
  Process.spawn(
    fn ->
      Process.sleep(5000)
    end,
    []
  )

Process.sleep(2000)
Process.alive?(my_process)
```

Use [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) and [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) to spawn a process that sleeps for five seconds. Use [Process.alive?/1](https://hexdocs.pm/elixir/Process.html#alive?/1) and [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) to check if the process is alive after six seconds. [Process.alive?/1](https://hexdocs.pm/elixir/Process.html#alive?/1) should return `false`.

```elixir
my_process =
  Process.spawn(
    fn ->
      Process.sleep(5000)
    end,
    []
  )

Process.sleep(6000)
Process.alive?(my_process)
```

## Process.send_after/4

Use [Process.send_after/4](https://hexdocs.pm/elixir/Process.html#send_after/4) and `self()` to send the process for the Elixir cell below a message after two seconds. Use [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) in the same cell to receive the message.

```elixir
Process.send_after(self(), "message", 2000, [])

receive do
  "message" -> IO.puts("Victory!")
end
```

Use [Process.spawn/3](https://hexdocs.pm/elixir/Process.html#spawn/3) to and [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) to spawn a process that waits to receive a message. Use [Process.send_after/4](https://hexdocs.pm/elixir/Process.html#send_after/4) to send the spawned process a message after two seconds.

```elixir
my_process =
  Process.spawn(
    fn ->
      receive do
        "message" -> IO.puts("My message!")
      end
    end,
    []
  )

Process.send_after(my_process, "message", 2000, [])
```

## Process.exit/2

Use [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) and [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) to spawn a process that sleeps for five seconds. Print `"I started"` before sleeping, and `"I finished"` after sleeping to prove if the process finishes sleeping or not. Use [Process.exit/2](https://hexdocs.pm/elixir/Process.html#exit/2) with the `:normal` exit reason to kill the spawned process.

Once finished, switch the exit reason to `:kill` to demonstrate that the process is unlinked, because it does not crash the calling process.

```elixir
my_process =
  Process.spawn(
    fn ->
      IO.puts("I started")
      Process.sleep(5000)
      IO.puts("I finished")
      Process.exit(self(), :normal)
    end,
    []
  )

Process.exit(my_process, :kill)
```

Use [Kernel.spawn_link/1](https://hexdocs.pm/elixir/Kernel.html#spawn_link/1) and [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) to spawn a linked process that sleeps for five seconds. Use [Process.exit/2](https://hexdocs.pm/elixir/Process.html#exit/2) with the `:normal` exit reason to kill the spawned process.

Notice that the Livebook does not crash. Switch the exit reason to `:kill` and notice that the Livebook does crash. Comment out your solution to avoid crashing Livebook.

```elixir
my_process =
  Kernel.spawn_link(fn ->
    IO.puts("I started")
    Process.sleep(10000)
    IO.puts("I finished")
  end)

# Process.exit(my_process, :kill)
```

```elixir
Process.list() |> Enum.count()
```

## Commit Your Progress

Run the following in your command line from the beta_curriculum folder to track and save your progress in a Git commit.
Ensure that you do not already have undesired or unrelated changes by running `git status` or by checking the source control tab in Visual Studio Code.

```
$ git checkout main
$ git checkout -b exercise-process_drills
$ git add .
$ git commit -m "finish process drills exercise"
$ git push origin exercise-process_drills
```

Then create a pull request to your `main` branch and notify your teacher by including `@BrooklinJazz` in your PR description to get feedback.

## Up Next

| Previous                                 | Next                                                   |
| ---------------------------------------- | -----------------------------------------------------: |
| [Processes](../reading/processes.livemd) | [Process Mailbox](../exercises/process_mailbox.livemd) |
